package rt.java.lang;


/**
 * 1 bit   mirrored property    镜像属性，如 【(
 * 4 bits  directionality property  方向性属性
 * 9 bits  signed offset used for converting case
 * 1 bit   if 1, adding the signed offset converts the character to lowercase
 * 1 bit   if 1, subtracting the signed offset converts the character to uppercase
 * 1 bit   if 1, this character has a titlecase equivalent (possibly itself)
 * 3 bits  0  may not be part of an identifier
 * 1  ignorable control; may continue a Unicode identifier or Java identifier
 * 2  may continue a Java identifier but not a Unicode identifier (unused)
 * 3  may continue a Unicode identifier or Java identifier
 * 4  is a Java whitespace character
 * 5  may start or continue a Java identifier;
 * may continue but not start a Unicode identifier (underscores)
 * 6  may start or continue a Java identifier but not a Unicode identifier ($)
 * 7  may start or continue a Unicode identifier or Java identifier
 * Thus:
 * 5, 6, 7 may start a Java identifier
 * 1, 2, 3, 5, 6, 7 may continue a Java identifier
 * 7 may start a Unicode identifier
 * 1, 3, 5, 7 may continue a Unicode identifier
 * 1 is ignorable within an identifier
 * 4 is Java whitespace
 * 2 bits  0  this character has no numeric property
 * 1  adding the digit offset to the character code and then
 * masking with 0x1F will produce the desired numeric value
 * 2  this character has a "strange" numeric value
 * 3  a Java supradecimal digit: adding the digit offset to the
 * character code, then masking with 0x1F, then adding 10
 * will produce the desired numeric value
 * 5 bits  digit offset
 * 5 bits  character type    字符类型 #getType
 */
public class CharacterDataLatin1Demo {


    String A_DATA =
            "\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800" +
                    "\u100F\u4800\u100F\u4800\u100F\u5800\u400F\u5000\u400F\u5800\u400F\u6000\u400F" +
                    "\u5000\u400F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800" +
                    "\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F" +
                    "\u4800\u100F\u4800\u100F\u5000\u400F\u5000\u400F\u5000\u400F\u5800\u400F\u6000" +
                    "\u400C\u6800\030\u6800\030\u2800\030\u2800\u601A\u2800\030\u6800\030\u6800" +
                    "\030\uE800\025\uE800\026\u6800\030\u2000\031\u3800\030\u2000\024\u3800\030" +
                    "\u3800\030\u1800\u3609\u1800\u3609\u1800\u3609\u1800\u3609\u1800\u3609\u1800" +
                    "\u3609\u1800\u3609\u1800\u3609\u1800\u3609\u1800\u3609\u3800\030\u6800\030" +
                    "\uE800\031\u6800\031\uE800\031\u6800\030\u6800\030\202\u7FE1\202\u7FE1\202" +
                    "\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1" +
                    "\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202" +
                    "\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1\202\u7FE1" +
                    "\202\u7FE1\uE800\025\u6800\030\uE800\026\u6800\033\u6800\u5017\u6800\033\201" +
                    "\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2" +
                    "\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201" +
                    "\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2\201\u7FE2" +
                    "\201\u7FE2\201\u7FE2\201\u7FE2\uE800\025\u6800\031\uE800\026\u6800\031\u4800" +
                    "\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u5000\u100F" +
                    "\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800" +
                    "\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F" +
                    "\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800" +
                    "\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F\u4800\u100F" +
                    "\u3800\014\u6800\030\u2800\u601A\u2800\u601A\u2800\u601A\u2800\u601A\u6800" +
                    "\034\u6800\030\u6800\033\u6800\034\000\u7005\uE800\035\u6800\031\u4800\u1010" +
                    "\u6800\034\u6800\033\u2800\034\u2800\031\u1800\u060B\u1800\u060B\u6800\033" +
                    "\u07FD\u7002\u6800\030\u6800\030\u6800\033\u1800\u050B\000\u7005\uE800\036" +
                    "\u6800\u080B\u6800\u080B\u6800\u080B\u6800\030\202\u7001\202\u7001\202\u7001" +
                    "\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202" +
                    "\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001" +
                    "\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\u6800\031\202\u7001\202" +
                    "\u7001\202\u7001\202\u7001\202\u7001\202\u7001\202\u7001\u07FD\u7002\201\u7002" +
                    "\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201" +
                    "\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002" +
                    "\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\u6800" +
                    "\031\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002\201\u7002" +
                    "\u061D\u7002";

    static final int A[] = new int[256];


    /**
     * 放置props的逻辑
     * 英文字母A 为例
     * i =130 j=65
     * int entry = data[130]<< 16;  =851968
     * A[65] = entry | data[131] = 851968 | '翡' 32737('翡' 0x7FE1)= 100000100000000000000000 | 111111111100001
     * =0000 0000 1000 0010 0111 1111 1110 0001(2进制)   这个值，下面会用
     * = 8552417 (10进制)
     * 问题来了，为什么要把 0x00000000100000100111111111100001 前分开文本，然后在合并使用
     * <p>
     * 不能用char储存，因为char的长度不够放 \u827fe1;   8552417 (10进制) = 827fe1(16进制)
     * 直接用B[] = int [] 数组 ，是可行的。但是有个缺点是 java 没有无符号的int , 只用负数表示第一位是1的情况。
     * 不知道为什么不使用这种方式。
     */
    public void initAData() {
        char[] data = A_DATA.toCharArray();
        assert (data.length == (256 * 2));
        int i = 0, j = 0;
        while (i < (256 * 2)) {
            int entry = data[i++] << 16;
            A[j++] = entry | data[i++];
        }
    }

    // 不能用char储存，因为char的长度不够放 \u827fe1;
    int BETTER_A[] = new int[]{1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1476411407, 1342193679, 1476411407, 1610629135, 1342193679, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1342193679, 1342193679, 1342193679, 1476411407, 1610629132, 1744830488, 1744830488, 671088664, 671113242, 671088664, 1744830488, 1744830488, -402653163, -402653162, 1744830488, 536870937, 939524120, 536870932, 939524120, 939524120, 402667017, 402667017, 402667017, 402667017, 402667017, 402667017, 402667017, 402667017, 402667017, 402667017, 939524120, 1744830488, -402653159, 1744830489, -402653159, 1744830488, 1744830488, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, 8552417, -402653163, 1744830488, -402653162, 1744830491, 1744850967, 1744830491, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, 8486882, -402653163, 1744830489, -402653162, 1744830489, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1342181391, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 1207963663, 939524108, 1744830488, 671113242, 671113242, 671113242, 671113242, 1744830492, 1744830488, 1744830491, 1744830492, 28677, -402653155, 1744830489, 1207963664, 1744830492, 1744830491, 671088668, 671088665, 402654731, 402654731, 1744830491, 134049794, 1744830488, 1744830488, 1744830491, 402654475, 28677, -402653154, 1744832523, 1744832523, 1744832523, 1744830488, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 1744830489, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 8548353, 134049794, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 1744830489, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 8482818, 102592514};

    public void moreReasonableInitAData() {
        char[] data = A_DATA.toCharArray();
        assert (data.length == (256 * 2));
        int i = 0, j = 0;
        while (i < (256 * 2)) {
            int entry = data[i++] << 16;
            A[j++] = entry | data[i++];
        }
    }

    public void testMoreReasonableInitAData() {
        int props = BETTER_A[65];
        System.out.println(props & 0x1F); // 测试getType

        for (int i = 0; i < BETTER_A.length; i++) {
            if (BETTER_A[i] < 0) {
                System.out.println(i); // 40
                // 查ascii码表，第40的
                break;
            }
        }
    }

    public static void main(String[] args) {
        CharacterDataLatin1Demo characterDataLatin1Demo = new CharacterDataLatin1Demo();
        characterDataLatin1Demo.testMoreReasonableInitAData();
    }
}
